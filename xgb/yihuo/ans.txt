答案解析:

非常简单的一道有关异或的题目

解题思路：

实际上就是要反推回原数组，首先，我们可以想到枚举任意数perm[0]来推回原数组。

但是如果任意指定这会有一个问题，你无法保证中途不会出现perm[i]=0的情况，而题目要求perm的每个数都必须是正整数，即可能会出现不符合题意的情况。

显然，如果通过大量枚举，无法保证时间复杂度可靠，我们必须使用O(t*n)复杂度的算法才能确保顺利通过此题。

也就是说，我们只能遍历常数次。

那这显然要我们想出一个perm[0]的数，而这个数能保证无论怎么被encoded[i]异或都不会变成0。

我们从数据范围得知encoded[i]的数据范围是大于1但小于10的9次方

只要我们找出一个数，这个数的一个2进制位大于10的9次方的任何数即可。

这个数显然可以知道就是int的最大值(2^31-1),但是我们不能使用这个值，因为它并不是真正的2的31次方。

那么我们将2的31次方除于2后得到2的30次方，也就是我们要的数:1073741824

这个数有什么特征呢？它是一个2的次方数，并且大于10的9次方，也就是说我们保证了无论怎么异或，中间perm[i]的值必定不会为0。

现在，我们知道了Perm[0]的值，就不难写出代码了，根据异或交换律，可得:

Encoded[i]=Perm[i]^Perm[i+1] => Perm[i+1]=Perm[i]^Encoded[i]

答案代码：

时间复杂度O(t*n),空间复杂度O(t*n)

#include<bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int t;
    cin>>t;
    while(t--){
        int n,temp;
        long long ans[100005];
        cin>>n;
        ans[0]=1073741824;
        for(int i=0;i<n;i++){
            cin>>temp;
            ans[i+1]=ans[i]^temp;
        }
        for(int i=0;i<n+1;i++) i!=n?cout<<ans[i]<<" ":cout<<ans[i];
        cout<<endl;
    }
    return 0;
}